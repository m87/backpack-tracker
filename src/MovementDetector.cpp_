#include "MovementDetector.h"

const int MovementDetector::MOG2 = 0;
const int MovementDetector::VIEW_INPUT_PREPROCESSED = 0;
const int MovementDetector::VIEW_INPUT_REAL = 1;


const std::string MovementDetector::MOG_METHOD = "mog";


MovementDetector::MovementDetector(std::string type) {
    MEMORY("MovementDetector created");

    _type = type;

    ConfigManager config = ConfigManager::getConfigManager();
    if(type == MOG_METHOD){
        initMogMethod(config);        

        }
}

MovementDetector::~MovementDetector() {
    MEMORY("MovementDetector destroyed");
}


vector<Group> MovementDetector::detect(const cv::Mat& input){
    if(_type == MOG_METHOD){
        return mog2Filter(input);
    }
    return mog2Filter(input);
}


vector<Group> MovementDetector::mog2Filter(const cv::Mat& input) {
    std::vector<cv::Vec4i> hierarchy;
    cv::Mat tmp;  

    input.copyTo(frameBg);
    input.copyTo(frameBg2);
    input.copyTo(tmp);

    cvtColor(input,frameNew,CV_RGB2GRAY);

    _mog2->apply(frameBg,frameDiff) ;
    _mog2->getBackgroundImage(frameBg);

    display(ConfigManager::VIEW_MOG_BACKGROUND, frameBg);

/*>>
    if(time==40){
        frameBg.copyTo(frameBg3);
    cvtColor(frameBg3,frameBg3,CV_RGB2GRAY);
    }


    cvtColor(frameBg,frameBg,CV_RGB2GRAY);

    absdiff(frameBg,frameNew , frameDiff2);

////////////////////////////////////
    Mat diff2, bg2,in ,in2;
     _mog22->apply(frameBg2,diff2) ;
     _mog22->getBackgroundImage(bg2);
    cvtColor(bg2,bg2,CV_RGB2GRAY);
    cvtColor(frameBg2,frameBg2,CV_RGB2GRAY);
   /* if(time>40){
    Mat w;
    bitwise_and(frameBg2,bg2,w);
    addBgRecord(w);
    
    }*/
//if(time % 50==0){
   // bitwise_and(in2,frameBg,in,Mat());
   // bitwise_not(in,in2,Mat());
    
//}
////////////////////////////////////////
/*>>
    element = _prep->getStructuringElement(_config->get<int>("mov-dilatation"),0);
    bitwise_or(frameDiff,frameDiff2,frameDiff3,Mat());
    
    threshold(frameDiff3, frameDiff3, _config->get<int>("mov-treshold"), 255,0);
    //absdiff(frameDiff,frameDiff2 , frameDiff3);


    frameDiff.copyTo(frameNoiseFree);
    
//if(time > 40){
    //absdiff(bg2,frameBg3,in2);
   // in2 = frameDiff3;
    //in2 = in2-diff2;
   // in2 = in2 - frameNoiseFree;
    //_prep->saveFrame(in2);
    
   // threshold(in2, in2, _config->get<int>("mov-treshold"), 255,0);
    //absdiff(in2,frameNoiseFree,in);
   // Mat element1 = _prep->getStructuringElement(3,0);
    //erode(in,in, element);
    //dilate(in,in, element);
   //at lol = Mat::zeros(in2.rows,in2.cols,0);
 //   _prep->getAvgFrame(lol);
    
//}

    addBgRecord(frameDiff3);

    dilate(frameDiff3,frameDiff3, element);
    //morphologyEx(frameDiff3, frameDiff3, 1, element);

    vector<Group> output;
    if(time % _config->get<int>("detection-step") == 0) {
        findContours( frameDiff3, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0)  );

        vector<Rect> boundRect(contours.size());
        vector<vector<Point> > contoursPoly(contours.size());
        Mat drawing;
        frameNew.copyTo(drawing);

        for( unsigned long i = 0; i< contours.size(); i++  )
        {
            approxPolyDP(Mat(contours[i]),contoursPoly[i],10,false);
            boundRect[i] = boundingRect(Mat(contoursPoly[i]));

            rectangle(frameNew, boundRect[i].tl(), boundRect[i].br(), cv::Scalar(0,255,0), 2,8,0);
            vector<Rect> found, found_filtered;
            Mat img1 = frameNew(boundRect[i]);
            Mat img;
            resize(img1,img,Size((img1.cols/(double)img1.rows)*200,200));

            Group group(img1.cols/(double)img.cols, img1.rows/(double)img.rows,boundRect[i].x, boundRect[i].y,img);
            output.push_back(group);
        }
    }

*/
    vector<Group>output;

    return output;
}

vector<vector<Point> > MovementDetector::getMovementROIs() {

    return contours;

}


void MovementDetector::addBgRecord(Mat bg){
   // if(skip++==   //     skip=0;
      if(step){
        bg.copyTo(buf1);
        
       }else
       {
           bg.copyTo(buf2);
           flag=true;
       }

       if(flag){
            Mat in;
            bitwise_and(buf1,buf2,in);
    imshow("lol1", in);
      }

    
}//}

vector<vector<Point> > MovementDetector::getStaticROIs(){
    vector<vector<Point> > output;
       



    return output;

}


void MovementDetector::initMogMethod(ConfigManager& config){
 WARNING("MovementDetector: Using " + MOG_METHOD);

        _mog2 = createBackgroundSubtractorMOG2(config.get<int>(ConfigManager::MD_MOG_HISTORY), config.get<int>(ConfigManager::MD_MOG_MIXTURES), config.get<bool>(ConfigManager::MD_MOG_SHADOW));
  //      _mog22 = createBackgroundSubtractorMOG2(20, config.get<int>(""), config.get<bool>("mog-shadow"));
   
    //    _bgBufferSize=config.get<int>("background-history-size");
    //    _bgBufferStep=config.get<int>("background-history-step");
        step=0;
        skip=0;
        flag=false;   
}


